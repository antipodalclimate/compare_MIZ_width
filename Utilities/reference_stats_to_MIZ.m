function reference_stats_to_MIZ(OPTS)
% REFERENCE_STATS_TO_MIZ Adjusts along-track statistics by referencing them to the MIZ.
%
% This function loads the along-track statistics generated by
% create_AT_stat_file.m and processes them to account for ascending and
% descending track components. It identifies the MIZ edge based on sea ice
% concentration and calculates the distance to the MIZ for each data point.
% The results are appended to the input .mat file.
%
% Inputs:
%   OPTS - A struct containing options and paths for the analysis:
%     .load_string - Path to the input .mat file with along-track stats.
%     .do_weak     - Flag indicating if weak beams were processed.

% Load the along-track statistics data.
load(OPTS.load_string, 'IS2_DATA');

% Determine the maximum number of beams to process.
if OPTS.do_weak
    maxB = 6;
else
    maxB = 3;
end

% Loop through each track file.
for i = 1:size(IS2_DATA.DS_stats, 1)
    beamct = 0;

    % Loop through each beam.
    for j = 1:6
        if ~isempty(IS2_DATA.DS_stats{i, j})
            beamct = beamct + 1;

            % Each track can cross the MIZ twice (ascending and descending).
            % Separate the data into two sides based on distance to the ice edge.
            side_indices{1} = IS2_DATA.DS_stats{i, j}.D_to_edge > 0; % Approaching edge
            side_indices{2} = IS2_DATA.DS_stats{i, j}.D_to_edge < 0; % Leaving edge

            % Check if both sides of the pole are present in the data.
            side_swap = [nansum(side_indices{1}) > 0, nansum(side_indices{2}) > 0];
            side_mult = [1, -1];
            search_dir = {'first', 'last'};

            % Process each side of the track.
            for side_index = 1:2
                if side_swap(side_index)
                    indices = side_indices{side_index};
                    offset = maxB * (side_index - 1);

                    % Store geographic and statistical data for the MIZ.
                    MIZ_DATA.timer{i, offset + beamct} = IS2_DATA.DS_stats{i, j}.timer;
                    MIZ_DATA.lat{i, offset + beamct} = IS2_DATA.DS_stats{i, j}.lat(indices);
                    MIZ_DATA.lon{i, offset + beamct} = IS2_DATA.DS_stats{i, j}.lon(indices);
                    MIZ_DATA.D_to_edge{i, offset + beamct} = IS2_DATA.DS_stats{i, j}.D_to_edge(indices);
                    MIZ_DATA.N_strict{i, offset + beamct} = IS2_DATA.DS_stats{i, j}.N_strict(indices);
                    MIZ_DATA.H{i, offset + beamct} = IS2_DATA.DS_stats{i, j}.H(indices);
                    MIZ_DATA.E{i, offset + beamct} = IS2_DATA.DS_stats{i, j}.E(indices);
                    MIZ_DATA.LIF{i, offset + beamct} = IS2_DATA.DS_stats{i, j}.LIF(indices);
                    MIZ_DATA.LIF_spec{i, offset + beamct} = IS2_DATA.DS_stats{i, j}.LIF_spec(indices);
                    MIZ_DATA.LIF_dark{i, offset + beamct} = IS2_DATA.DS_stats{i, j}.LIF_dark(indices);
                    MIZ_DATA.WAF{i, offset + beamct} = IS2_DATA.DS_stats{i, j}.WAF(indices);
                    MIZ_DATA.SIC{i, offset + beamct} = IS2_DATA.DS_stats{i, j}.SIC(indices);

                    try
                        MIZ_DATA.RFSD{i, offset + beamct} = IS2_DATA.DS_stats{i, j}.RFSD(indices);
                        MIZ_DATA.MFSD{i, offset + beamct} = IS2_DATA.DS_stats{i, j}.MFSD(indices);
                    catch
                    end

                    if IS2_DATA.v6 == 1
                        MIZ_DATA.SIC_amsr{i, offset + beamct} = IS2_DATA.DS_stats{i, j}.SIC_amsr(indices);
                    end

                    % Find the MIZ edge (where sea ice concentration > 80%).
                    MIZ_edge = find(MIZ_DATA.SIC{i, offset + beamct} > 0.8, 1, search_dir{side_index});

                    % Calculate distance to the MIZ edge.
                    if ~isempty(MIZ_edge)
                        MIZ_DATA.D_to_MIZ{i, offset + beamct} = side_mult(side_index) * (MIZ_DATA.D_to_edge{i, offset + beamct} - MIZ_DATA.D_to_edge{i, offset + beamct}(MIZ_edge));
                    else
                        MIZ_DATA.D_to_MIZ{i, offset + beamct} = nan * MIZ_DATA.D_to_edge{i, offset + beamct};
                    end

                    MIZ_DATA.is_reversed(i, offset + beamct) = side_index - 1;
                end
            end
        end
    end
end

% Append the MIZ data to the original .mat file.
save(OPTS.load_string, 'MIZ_DATA', '-append');


